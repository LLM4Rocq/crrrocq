prompt = """# Chain of Thought Generation Task

## Introduction

We are a team of researchers specializing in machine learning, particularly LLMs, and formal methods, especially the Coq proof assistant. Our goal is to improve LLM performance in generating Coq proofs. We have an idea to achieve this goal: ensure that the chains of thought (CoT) generated by our LLMs interact extensively with the interactive Coq prover. For this, we want LLMs to be able to call various 'tools' in their CoT in the following manner:

```
...
<think> some thinking part from the LLM </think>
<search> searching for some pre-existing theorems </search>
<result> the results of the search </result>
<think> another thinking part </think>
<script> some attempt at writing some Coq code </script>
<result> the results of the script </result>
<have> some attempt at doing a have tactic </have>
<result> the results of attempt at writing a have tactic </result>
...
```

We will generate a dataset of CoT examples starting from theorems already proven in math-comp, the largest mathematics library in Coq. With this dataset, we will train a model using supervised fine-tuning that will know how to use tools in its CoTs.

## Your Task

You are part of the team, and your role is to generate these CoTs. You are particularly skilled in Coq, so this work is perfect for you! Since you already have the proofs of the theorems, you simply need to look at the proof, simulate the reasoning that went through the mind of the person who wrote it, and write this reasoning in the expected format: with tags delimiting tool calls. Since the results of the calls are not to be generated by the LLMs, you don't need to write the `<result> ... </result>` parts; they will be added later by another team member.

To help you simulate the CoTs and know when to simulate tool calls, the proofs of the theorems will be given to you in a particular format. The following instructions describe this format and the procedure for writing the CoTs.

## Input Format

First, you are given what needs to be proven, i.e., the Coq version of the theorem as well as a more primitive version of the theorem in the form of its initial goal. The initial goal is a list of hypotheses (which will show the global variables) and the Coq goal.

Next, we want a decomposition of the proof into small pieces to simulate a step-by-step progression in the proof. Naturally in Coq, we can segment a proof by cutting at the level of periods '.', and each small piece will be a sequence of tactics connected by semicolons ';', which we call a chain. Thus, to simulate the reasoning leading to the total proof, we will simply connect the reasoning leading to each chain of the proof. It is therefore crucial to properly simulate the reasoning leading to a chain, and thus to have the right information necessary for this simulation. Since LLMs can call tools, particularly a search tool, we will provide, in addition to a chain, all its dependencies (lemmas, theorems, definitions, etc. that the LLM does not yet know and that appear in this chain). A dependency is given with its type and a docstring for dependencies that have one.

Also, since it is very important to make the connection between the chains and logically understand what leads from one chain to the next, we will provide the difference in goals between two consecutive chains. This goal difference will allow you to explain the transition between chains in the CoTs.

Thus, we provide a list alternating between the chains of the proof and their dependencies (if any) and the differences in goals between the previous chain and the next chain (if any).

For example, here is a theorem and its proof for which you might have to write the CoT:
```coq
Lemma galNormX n : {morph galNorm U V : a / a ^+ n}.
Proof.
move=> a; elim: n => [|n IHn]; first exact: galNorm1.
by rewrite !exprS galNormM IHn.
Qed.
```
Here is how it will be given to you:
```
<theorem>
Lemma galNormX n : {morph galNorm U V : a / a ^+ n}.
</theorem>

<initial goal>
F  : fieldType
L  : splittingFieldType F
U, V  : {vspace L}
n  : nat
|-{morph galNorm U V : a / a ^+ n}
</initial goal>

<proof>

<chain>
move=> a; elim: n => [|n IHn]; first exact: galNorm1.
</chain>
<dependencies>
galNorm1 : galNorm U V 1 = 1.
</dependencies>
<goal diff>
Goals modified:
The goal 0 is changed:
Hypotheses added:
a : L
IHn : galNorm U V (a ^+ n) = galNorm U V a ^+ n

The goal changed to
|-galNorm U V (a ^+ n.+1) = galNorm U V a ^+ n.+1
</goal diff>

<chain>
by rewrite !exprS galNormM IHn.
</chain>
<dependencies>
exprS : forall [R : pzSemiRingType] (x : R) (n : nat), x ^+ n.+1 = x * x ^+ n

galNormM : {morph galNorm U V : a b / a * b}
</dependencies>
<goal diff>
1 goal has been removed.
There is no goal remaining, the proof is finished.
</goal diff>

</proof>
```

## Available Tools Overview

### Think Block

Between the tags `<think>` and `</think>`, this corresponds to a classic reasoning phase of an LLM. It's the default mode that doesn't correspond to calling any tools. In the CoT simulation, you should write thought blocks whenever something needs to be explained in informal language.

### Search Block

This is a very important block for the LLM as it allows it to understand the environment it's in and which theorems it has access to. In this block, the LLM writes a description of a theorem that might be useful to it, and the result is provided by a search algorithm comparing text embeddings.

To simulate such a block, such a call to this tool, you can use the dependencies of each chain. In fact, you know that the LLM must search for these theorems to write the chain. For each theorem in the dependencies, you can write a search bloc that would result in this theorem. In the CoT, the result of your search would give the theorem that interests you as well as other theorems that you don't need to use. The following part of the CoT reasoning should justify the choice to keep the theorem and describe how to use it in writing the chain.

Additionally, if you feel that multiple theorems present in the chain's dependencies have very similar meanings and could appear in the result of the same search, then you can write a single search block for these theorems. You must then properly justify selecting multiple theorems from the search results and subsequently describe how to use them to write the chain. Be careful when proceeding this way - it is essential that the theorems you group together have closely related meanings to ensure the logical coherence of the reasoning.

Continuing in the middle of the proof of the previous example, we want to simulate the reasoning leading to the chain `by rewrite !exprS galNormM IHn.`. The dependencies of this chain are exprS and galNormM. Since these two theorems are quite different there should be two search blocs, the first concerning the exprS theorem and the second concerning the galNormM theorem. Here is a CoT simulation you might have written:

```
<think>
Now, we have to prove that `galNorm U V (a ^+ n.+1) = galNorm U V a ^+ n.+1` with the new hypotheses `a : L` and `IHn : galNorm U V (a ^+ n) = galNorm U V a ^+ n`. We are trying to prove the goal by induction, so we should be able to use the induction hypothesis IHn to finish the proof. To do so, we have to transform the main goal to make the statement of IHn appear. Because the main goal use a ^+ n.+1 where IHn use a ^+ n, the first step could be to decompose a ^+ n.+1 to make a ^+ n appear. With great probability, ^+ denotes the exponentiation so a theorem doing what we want should already exists.
</think>

<search>
A theorem stating the recursive definition of exponentiation.
</search>
```
Here, we stop the LLM's inference and write the results of its search block. Among the results will be the theorem exprS.

```
<think>
Among the results, the theorem `exprS` seems to be particularly fitted for our use case. Rewriting with this theorem everywhere, the main goal would become `galNorm U V (a * a ^+ n) = galNorm U V a * galNorm U V a ^+ n`. This is really good because it makes galNorm U V a ^+ n, the right side of the equality in IHn, appear. Now, it remains to make the left side of the equality in IHn appear in the left side of the equality of the main goal. To be able to use IHn properly, the left side of the equality should even be transformed to galNorm U V a * galNorm U V (a ^+ n). Looking at it, we see that we need galNorm U V to preserve the multiplication. Maybe there already exists a theorem for this.
</think>

<search>
A theorem showing that galNorm U V preserve multiplication.
</search>
```
We stop the LLM's inference again and write the results of its search block. Among the results will be the theorem galNormM.

### Script Block

Following the example above, the LLM now has all the information needed to finish the proof, he must now propose its code. This is exactly the purpose of script blocks. The LLM proposes code and we check on our side if its Coq code type-checks. If the code type-checks, we return the new goal; otherwise, we return the Coq error. The final proof will be the concatenation of all the valid script blocks written.

You should simulate this block whenever the LLM is expected to propose code, so for each chain of the input. This is easy for you: you explain, as seen previously, the reasoning that leads to a chain, then you write the chain in a script block. You don't have to write the result block, but the changes in goal caused by the chain are written in the input, so you can proceed as if you had seen the result of the script.

After a script block, you should never explain what is inside of it. If your simulation of a CoT is well crafted, all that explains the code inside of the script block should be stated in the reasonning part BEFORE that block.

To illustrate this, lets continue the previous example just after the last search block. It remains to write a paragraph aknowledging the result of the search and gathering all the previous information to write the chain:
```
<think>
Nice, the theorem galNormM correspond exactly to what we are looking for! Indeed, it is a math-comp theorem saying that galNorm U V preserve the multiplication. So for all a and b, galNorm U V (a * b) = galNorm U V a * galNorm U V b. Rewriting it in the goal, it gives `galNorm U V a * galNorm U V (a ^+ n) = galNorm U V a * galNorm U V a ^+ n`. To finish the proof is simple, it remains to rewrite with IHn and the equality is trivial. In total, I advice starting the line with `by`because it will solve the trivial equality remaining at the end, then we rewrite all theorems with `rewrite !exprS galNormM IHn`. It is important to put a `!` before exprS because we want to rewrite it several times.
</think>

<script>
by rewrite !exprS galNormM IHn.
</script>
```

### Have Block

Now, I will present a convenient tool available to the LLM. Actually, the idea is to prevent the LLM from writing proofs that are too long. For this, the LLM can use a math-comp concept, the `have` tactic that introduces a new hypothesis into the context. After writing this tactic, you now need to prove this new hypothesis. It's the proof of this latter that the LLM won't have to do; it will be done by a dedicated tool. A have block allows calling this tool by giving it the have tactic to do.

But when should you simulate this block? Not all haves written in math-comp are interesting for us; we have selected those that interest us by framing them with tags `(*<have>*)` and `(*</have>*)` in the Coq code. Only when you see these tags should you make a have block. Moreover, the have will be incomplete, its proof will be hidden and replaced by `(*proof*)` because you don't need to know it.

To properly simulate a call to the have tool, we have an idea: do it following a search block that didn't give what you want. In fact, when you encounter an interesting have, first start with a search block that corresponds to what the have does. Then, consider that there's nothing that interests you in the result of the search. You will then make a have block to overcome this lack and justify the need to write a have.

For example, if you have to simulate the application of the chain `(*<have>*) have Uxy: (x * y \\in unit). (*proof*) (*</have>*)` when the goal is `(x * y)^-1 = y^-1 / x` and the hypotheses `x : R`, `y : R`, `Ux : x \is a unit` and `Uy : y \is a unit` have just been introduced, you could write something like this:

```
<think>
Now we have to prove that `(x * y)^-1 = y^-1 / x` knowing that `x : R`, `y : R` and `Ux : x \is a unit`, `Uy : y \is a unit`. To be able to apply further interesting theorems, we have to be sure that x * y is invertible, maybe there already exists some theorems proving that.
</think>

<search>
A theorem showing that if x and y are invertible, then so is x * y.
</search>

<think>
Mmh, I find no interesting theorems to apply to the proof in the result. So I think I will state what I want as a have tactic.
</think>

<have>
have Uxy: (x * y \\in unit).
</have>
```
Here, we stop the LLM's inference and write the result of the have tactic, namely the goals difference given to you.

```
<think>
Nice, the hypothesis `Uxy : x * y \is a unit` has been added to the context. I can move on with the proof and ...
</think>
```

Note that some have tactics may have dependencies, such as lemmas that are directly applied to the result of the have or that appear in its statement. Treat these dependencies as before by creating search blocks. To maintain logical flow, the search block sometimes needs to come before or after the have block - use your expertise and judgment to determine the most natural placement that preserves the reasoning coherence. Also, don't forget what was mentioned previously: the have block still needs to be simulated by an unsuccessful search block. So you should have some search blocks for dependencies and a failed search block that triggers the have block corresponding to the have tactics.

## Final Instructions

- Keep the context in mind: what is your goal, what are your hypotheses, where are you in the proof.
- Detail the reasoning: it is essential that it is complete and realistic for the LLM to be well trained. Simulate a genuine reflection with moments of research and reactions to the results of the tools. It should be as if you were in the mind of a person finding the proof of the theorem using the tools available.
- Use the tools properly: it is crucial that the tools are well used in the CoT examples you will write. Follow the instructions as much as possible and apply the tools at the right time. Precisely simulate their integration into the reasoning and how they help to finish the proof.
- Formulate your searches perfectly: when you call a search block, make sure that your query directs clearly and unambiguously towards the theorems you expect to have in the results, without being too verbose.
- Ensure logical chain sequencing: sometimes a chain is written to set the stage for a subsequent chain. If you identify such a case, adapt your reasoning accordingly. To maintain a faithful and logical simulation, first include a reflection section (which may contain tool calls) explaining what you want to accomplish overall. Then simulate realizing that this isn't immediately possible because certain prerequisites are missing. At this point, explain how the first chain prepares the groundwork, provide its code in a script block, and then continue with the subsequent reasoning that builds on this foundation.
- Main rule: never reference any part of the proof given in the input before developing reasoning that leads to that code. You must not talk about chains, especially not future chains, and not about code that hasn't been built step by step through reasoning. It is crucial that the CoT you generate gives the impression that the proof is being constructed through progressive reasoning and was not known in advance. The simulation should authentically represent discovery, not recall of a known solution.

Are you ready?

Here is the first math-comp theorem for which you need to simulate the CoT:
"""
